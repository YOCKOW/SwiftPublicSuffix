name: Auto-update
on:
  schedule:
    - cron: "0 0 * * 0"
  workflow_dispatch: # Enable to run manually
permissions:
  contents: write
  pull-requests: write
jobs:
  auto-update:
    strategy:
      fail-fast: false
      matrix:
        include:
          - major-version: 2
            minor-version: 4
            base-branch: main
    runs-on: ubuntu-24.04
    env:
      MAJOR_VERSION: ${{ matrix.major-version }}
      MINOR_VERSION: ${{ matrix.minor-version }}
      BASE_BRANCH: ${{ matrix.base-branch }}
      UP_TO_DATE_BRANCH: "up-to-date/v${{ matrix.major-version }}.${{ matrix.minor-version }}"
      GIT_USER_NAME: "github-actions[bot]"
      GIT_USER_EMAIL: "41898282+github-actions[bot]@users.noreply.github.com"
      GIT_REMOTE_NAME: origin
    name: "Auto-update: v${{ matrix.major-version }}.${{ matrix.minor-version }}.x (Base Branch: ${{ matrix.base-branch }})"
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install --no-install-recommends -y git zsh libcurl4-openssl-dev
      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Use a cache for ".build" directory.
        uses: actions/cache@v4
        with:
          path: .build
          key: build-${{ github.workspace }}-${{ runner.os }}-auto-update-${{ env.UP_TO_DATE_BRANCH }}
          restore-keys: |
            build-${{ github.workspace }}-${{ runner.os }}-auto-update-${{ env.UP_TO_DATE_BRANCH }}
            build-${{ github.workspace }}-${{ runner.os }}-auto-update-
            build-${{ github.workspace }}-${{ runner.os }}-
            build-${{ github.workspace }}-
      - uses: YOCKOW/Action-setup-swift@main
        with:
          swift-version: "6.2.3"
      - name: Configure git.
        run: |
          set -x
          git config --local user.name "${GIT_USER_NAME}"
          git config --local user.email "${GIT_USER_EMAIL}"
      - name: Generate necessary environment variables
        shell: zsh {0}
        env:
          REF_NAME: ${{ github.ref_name }}
          DEBUG_LOGGING: ${{ runner.debug }}
        run: |
          set -eu

          git fetch "${GIT_REMOTE_NAME}" --tags

          # NOTE: `grep` on Ubuntu (with GitHub Actions) doesn't recognize `\d`.
          declare -r grepPattern="^${MAJOR_VERSION}"'\.'"${MINOR_VERSION}"'\.[0-9]+$'
          echo "::debug::Pattern for grep: ${grepPattern}"
          if [[ "${DEBUG_LOGGING}" = "1" ]] || [[ "$REF_NAME" = "development" ]]; then
            echo "::group::(DEBUG) All Tags"
            git tag
            echo "::endgroup::"

            echo "::group::(DEBUG) Version Candidates"
            set +e
            git tag | grep -E "$grepPattern"
            set -e
            echo "::endgroup::"
          fi

          declare -i versionCount=0
          declare -i latestPatchVersion=0
          declare -i currentPatchVersion=0
          declare vTag
          while IFS= read -r vTag; do
            versionCount=$(( $versionCount + 1 ))
            currentPatchVersion=${vTag##*.}
            echo "::debug::Current found version: ${vTag}"
            echo "::debug::Current patch number: ${currentPatchVersion}"
            if [[ $latestPatchVersion -lt $currentPatchVersion ]]; then
              echo "::debug::${vTag} is newer than ${MAJOR_VERSION}.${MINOR_VERSION}.${latestPatchVersion}"
              latestPatchVersion=$currentPatchVersion
            else
              echo "::debug::${vTag} is NOT newer than ${MAJOR_VERSION}.${MINOR_VERSION}.${latestPatchVersion}"
            fi
          done < <(git tag | grep -E "$grepPattern")

          if [[ $versionCount -lt 1 ]]; then
            echo "::error::No versions for ${MAJOR_VERSION}.${MINOR_VERSION}.* found?!"
            exit 1
          fi

          declare -r jobUUID=$(uuidgen)
          declare -r -i nextPatchVersion=$(( $latestPatchVersion + 1 ))
          echo "LATEST_PATCH_VERSION=$latestPatchVersion" >>"$GITHUB_ENV"
          echo "LATEST_VERSION=${MAJOR_VERSION}.${MINOR_VERSION}.${latestPatchVersion}" >>"$GITHUB_ENV"
          echo "NEXT_PATCH_VERSION=${nextPatchVersion}" >>"$GITHUB_ENV"
          echo "NEXT_VERSION=${MAJOR_VERSION}.${MINOR_VERSION}.${nextPatchVersion}" >>"$GITHUB_ENV"
          echo "JOB_UUID=$jobUUID" >>"$GITHUB_ENV"
          echo "JOB_DATE=$(date '+%Y-%m-%d %H:%M:%S%z')" >>"$GITHUB_ENV"
          echo "TMP_BRANCH=auto-update-$jobUUID" >>"$GITHUB_ENV"
      - name: Update the list on `${{ env.UP_TO_DATE_BRANCH }}` branch
        env:
          GH_TOKEN: ${{ secrets.AUTO_UPDATE_TOKEN }}
        run: |
          set -eu

          git checkout "${LATEST_VERSION}"
          git switch -c "${TMP_BRANCH}"

          git fetch "${GIT_REMOTE_NAME}" "${UP_TO_DATE_BRANCH}"
          git merge "${GIT_REMOTE_NAME}/${UP_TO_DATE_BRANCH}"
          if [[ -n "${BASE_BRANCH}" ]]; then
            git fetch "${GIT_REMOTE_NAME}" "${BASE_BRANCH}"
            git merge "${GIT_REMOTE_NAME}/${BASE_BRANCH}"
          fi

          ./utils/update --commit
          git push --set-upstream "${GIT_REMOTE_NAME}" "${TMP_BRANCH}:${TMP_BRANCH}"
          ./utils/create-pr-and-merge \
            --remote-name "${GIT_REMOTE_NAME}" \
            --base-branch "${UP_TO_DATE_BRANCH}" \
            --head-branch "${TMP_BRANCH}" \
            --pr-title "Update the list; Candidate for \`${NEXT_VERSION}\`." \
            --pr-body "This PR was created automatically."$'\n\n'"- Job UUID: ${JOB_UUID}"$'\n'"- Date: ${JOB_DATE}" \
            --delete-branch
      - name: Add a new tag if necessary
        id: new-tag
        run: |
          set -eu

          git fetch "${GIT_REMOTE_NAME}" "${UP_TO_DATE_BRANCH}"
          git checkout "${UP_TO_DATE_BRANCH}"
          git pull

          declare updateSummary=""
          declare updateSummaryOnBase=""
          updateSummary=$(git diff --shortstat "${LATEST_VERSION}..HEAD")
          if [[ -n "${BASE_BRANCH}" ]]; then
            updateSummaryOnBase=$(git diff --shortstat "${GIT_REMOTE_NAME}/${BASE_BRANCH}..HEAD")
          fi
          echo "update-summary=$updateSummary" >>"$GITHUB_OUTPUT"
          echo "update-summary-on-base=$updateSummaryOnBase" >>"$GITHUB_OUTPUT"
          if [[ -z "$updateSummary" ]]; then
            echo "::notice::${LATEST_VERSION} is up-to-date."
            exit 0
          fi
          git tag "$NEXT_VERSION"
          git push "$GIT_REMOTE_NAME" tag "$NEXT_VERSION"
      - name: Merge updated list into `${{ env.BASE_BRANCH || '- n/a -' }}` branch.
        if: >-
          ${{
            env.BASE_BRANCH != '' &&
            steps.new-tag.outputs.update-summary-on-base != ''
          }}
        env:
          GH_TOKEN: ${{ secrets.AUTO_UPDATE_TOKEN }}
          UPDATE_SUMMARY: ${{ steps.new-tag.outputs.update-summary }}
          UPDATE_SUMMARY_ON_BASE: ${{ steps.new-tag.outputs.update-summary-on-base }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -eu

          declare -r versionCmpURL="https://GitHub.com/${REPOSITORY}/compare/${LATEST_VERSION}...${NEXT_VERSION}"
          declare -r baseCmpURL="https://GitHub.com/${REPOSITORY}/compare/${BASE_BRANCH}...${NEXT_VERSION}"
          declare -r prBody="
          This PR was created automatically.

          - Update Summary (${LATEST_VERSION} to ${NEXT_VERSION}): [${UPDATE_SUMMARY}](${versionCmpURL})
          - Update Summary (${BASE_BRANCH} to ${NEXT_VERSION}): [${UPDATE_SUMMARY_ON_BASE}](${baseCmpURL})
          - Job UUID: ${JOB_UUID}
          - Date: ${JOB_DATE}
          "
          ./utils/create-pr-and-merge \
            --remote-name "${GIT_REMOTE_NAME}" \
            --base-branch "${BASE_BRANCH}" \
            --head-branch "${UP_TO_DATE_BRANCH}" \
            --pr-title 'Merge updated list into `'"${BASE_BRANCH}"'` branch.' \
            --pr-body "${prBody}"
